theme(panel.background = element_rect(fill = "white", colour = "black", size = 0.5), # opcoes graficas
panel.grid.major = element_line(colour = NA),
panel.grid.minor = element_line(colour = NA),
axis.text = element_text(colour = "black", size = 10),
axis.text.x = element_blank(),
axis.title.x=element_blank(),
axis.title = element_text(colour = "black", size = 12, face = "bold"),
legend.title = element_blank(),
legend.background = element_rect(fill = "white"),
legend.text = element_text(face = "bold", colour = "black", size = 16))
Salinity<-ggplot()+
geom_boxplot(aes(x=trawlings$species,y=trawlings$sal),
notch=TRUE,fill="grey")+
ylab("Salinity (?)")+
theme(panel.background = element_rect(fill = "white", colour = "black", size = 0.5), # opcoes graficas
panel.grid.major = element_line(colour = NA),
panel.grid.minor = element_line(colour = NA),
axis.text = element_text(colour = "black", size = 10),
axis.text.x = element_blank(),
axis.title.x=element_blank(),
axis.title = element_text(colour = "black", size = 12, face = "bold"),
legend.title = element_blank(),
legend.background = element_rect(fill = "white"),
legend.text = element_text(face = "bold", colour = "black", size = 16))
Temperature<-ggplot()+
geom_boxplot(aes(x=trawlings$species,y=trawlings$temp),
notch=TRUE,fill="grey")+
xlab("Species")+
ylab("Temperature (ÂºC)")+
theme(panel.background = element_rect(fill = "white", colour = "black", size = 0.5), # opcoes graficas
panel.grid.major = element_line(colour = NA),
panel.grid.minor = element_line(colour = NA),
axis.text = element_text(colour = "black", size = 10),
axis.title = element_text(colour = "black", size = 12, face = "bold"),
legend.title = element_blank(),
legend.background = element_rect(fill = "white"),
legend.text = element_text(face = "bold", colour = "black", size = 16))
figure3<-grid.arrange(Depth,Salinity,Temperature,nrow=3)
ggsave("Figures/Figure 3.png",figure3,dpi=600,height=24,width=16,units=c("cm"))
# PCA for environmental variables #
env<-aggregate(trawlings[,7:9],list(trawlings$trawl),mean)
row.names(env)<-env$Group.1
env<-env[,-1]
pc.env<-princomp(decostand(env,method="standardize"),cor=TRUE)
eigenvals(pc.env) #Selecting first axis by Kaiser-Guttman criterion
summary(pc.env) #First axis explains 53.4% of total variation
pc.env$loadings #Depth and salinity are positively related to the first PC
scores<-pc.env$scores
loadings<-as.data.frame(pc.env$loadings[c(1:3),])
write.table(scores,"results/env_pcs.txt")
# Plotting PCA #
Suppl.Fig2<-ggplot()+
geom_point(mapping=aes(x=scores[,1],y=scores[,2]),size=2,alpha=0.15)+
xlab("PC1 (53.41%)")+  ylab("PC2 (32.93%)")+
geom_segment(aes(x=0,xend=loadings[,1]*2,y=0,yend=loadings[,2]*2),
arrow = arrow(length = unit(0.5, "cm")),colour="blue",
size=0.8,alpha=0.5,inherit.aes=FALSE)+
geom_text(aes(x=(loadings[,1]*2+0.3),y=(loadings[,2]*2+0.16),label=c("Depth","Salinity","Temperature")),
size=4,color="blue",fontface="bold",alpha=0.5)+
theme(panel.background = element_rect(fill = "white", colour = "black", size = 0.5), # opcoes graficas
panel.grid.major = element_line(colour = NA),
panel.grid.minor = element_line(colour = NA),
axis.text = element_text(colour = "black", size = 12),
axis.title = element_text(colour = "black", size = 14, face = "bold"),
legend.title = element_blank(),
legend.background = element_rect(fill = "white"),
legend.text = element_text(face = "bold", colour = "black", size = 10))
ggsave("Suppl. Fig. 2.png",Suppl.Fig2,dpi=600,height=10,width=10,units=c("cm"))
### Pacotes utilizados ###
library(reshape)
library(vegan)
library(ade4)
library(Rmisc)
### Importing dataset and building Site x Sp. matrix ###
data<-read.table("data/trawling data.txt",header=T)
comm<-cast(data[,c(1:3)],trawl~species,value='pres',fun.aggregate=mean)
comm[is.na(comm)]<-0
row.names(comm)<-comm$trawl
comm<-comm[,-1]
### Reading C-score index function ###
# This function was retrieved from D'Amen et al. (2017). If you use this function, cite:
# D'Amen, Gotelli & Guisan (2017) Disentangling biotic interactions, environmental filters, and dispersal limitation as drivers of species co-occurrence. Ecography, 41 (8): 1233-1244. ##
ecospat.Cscore01 <- function(data.in,npermut,outpath){
# C-coef Observed matrix
cat("Computing observed co-occurence matrix", "\n",append = F)
cat(".............", "\n",append = F)
cat(".............", "\n",append = F)
cat(".............", "\n",append = F)
spec.occ <- data.matrix(data.in)
####  C score #############
coocc<-t(spec.occ)%*%spec.occ  # nb of checkboard units
n.spec=dim(coocc)[1]
mat1<-array(apply(spec.occ,MAR=2,sum),dim=c(n.spec,n.spec))
mat2<-t(array(apply(spec.occ,MAR=2,sum),dim=c(n.spec,n.spec)))
mat.obs.c.coef <- ((mat1 - coocc)*(mat2 - coocc))/(mat1*mat2) # observed c score
df.obs.c.coef <- data.frame(Col = rep(1:ncol(mat.obs.c.coef),each=ncol(mat.obs.c.coef)),Row = rep(1:nrow(mat.obs.c.coef),
nrow(mat.obs.c.coef)),Sp1 = rep(colnames(mat.obs.c.coef),each=ncol(mat.obs.c.coef)),
Sp2 = rep(rownames(mat.obs.c.coef),nrow(mat.obs.c.coef)),Co.Occ = c(mat.obs.c.coef)) # dataframe with cscore for each species pair
v.diago.inf <- c(rownames(df.obs.c.coef)[df.obs.c.coef[,1]>df.obs.c.coef[,2]],rownames(df.obs.c.coef)[df.obs.c.coef[,1]==df.obs.c.coef[,2]])# Remove identical combinations of species
df.obs.c.coef <- df.obs.c.coef[-as.numeric(v.diago.inf),]
CscoreTot<-mean(df.obs.c.coef$Co.Occ)
# Matrix to store the permuations
mat.perm <- matrix(0,nrow(df.obs.c.coef),npermut, dimnames = list(c(paste(df.obs.c.coef[,3],df.obs.c.coef[,4])),c(1:npermut)))
# Permutations C-coef
cat("Computing permutations", "\n",append = F)
cat(".............", "\n",append = F)
for (i in 1:npermut)
{
if (i == 1)
{
cat(npermut ," permutations to go", "\n",append = F)
cat(".............", "\n",append = F)
}
if (i == npermut / 2)
{
cat(npermut / 2," permutations to go", "\n",append = F)
cat(".............", "\n",append = F)
}
spec.occ.perm1<-data.matrix(data.in)
spec.occ.perm1 <- permatswap(spec.occ.perm1,fixedmar="both",mtype="prab",time=1) # row/column sums are preserved
# time=1 : separate swapping sequence that always begins with the original matrix
spec.occ.perm <- as.matrix(spec.occ.perm1[[3]][[1]] )
coocc.perm <- t(spec.occ.perm)%*%spec.occ.perm
mat1.perm <- array(apply(spec.occ.perm,MAR=2,sum),dim=c(n.spec,n.spec))
mat2.perm <- t(array(apply(spec.occ.perm,MAR=2,sum),dim=c(n.spec,n.spec)))
mat.obs.c.coef.perm <- ((mat1.perm - coocc.perm)*(mat2.perm - coocc.perm))/(mat1.perm*mat2.perm)
df.obs.c.coef.perm <- data.frame(Col = rep(1:ncol(mat.obs.c.coef.perm),each=ncol(mat.obs.c.coef.perm)),Row = rep(1:nrow(mat.obs.c.coef.perm),
nrow(mat.obs.c.coef.perm)),Sp1 = rep(colnames(mat.obs.c.coef),each=ncol(mat.obs.c.coef.perm)),
Sp2 = rep(rownames(mat.obs.c.coef),nrow(mat.obs.c.coef.perm)),Co.Occ = c(mat.obs.c.coef.perm))
# Remove identical combinations of species (same Co-occ coef) and the diagonal (Co-occ coeff = 0)
df.obs.c.coef.perm <- df.obs.c.coef.perm[-as.numeric(v.diago.inf),]
# Store result of permuation
mat.perm[,i] <- df.obs.c.coef.perm[,5]
}
## for the whole community
vec.CScore.tot<-as.vector(apply(mat.perm,MAR=2,mean)) # C-score for all null communities (mean on the columns)
SimulatedCscore<-mean(vec.CScore.tot) # mean of Simulation C-score: Simulated C-score
sd.SimulatedCscore<-sd(vec.CScore.tot) # standard deviation of null communities
Zscore<-(CscoreTot-SimulatedCscore)/sd.SimulatedCscore # standardized effect size
randtest.less<-as.randtest(vec.CScore.tot, CscoreTot, alter="less")
pval.less<-randtest.less$pvalue
randtest.greater<-as.randtest(vec.CScore.tot, CscoreTot, alter="greater")
pval.greater<-randtest.greater$pvalue
plot(randtest.greater, xlab= "Simulated C-scores",main=paste("", sep=""))
# Calculate P-values based on random distribution
mat.pval <- matrix(0,nrow(mat.perm),4,dimnames = list(rownames(mat.perm),c("Obs.Co.Occ","Zscore","pval_less","pval_greater")))
mat.pval[,1] <- df.obs.c.coef[,5]
cat("Computing P-values", "\n",append = F)
cat(".............", "\n",append = F)
for (k in 1:nrow(mat.perm))
{
mat.pval[k,2]<-	(df.obs.c.coef[k,5]-mean(mat.perm[k,]))/sd(mat.perm[k,])
randtest<-as.randtest(sim=mat.perm[k,], obs=df.obs.c.coef[k,5], alter="less")
mat.pval[k,3]<-randtest$pvalue
randtest<-as.randtest(sim=mat.perm[k,], obs=df.obs.c.coef[k,5], alter="greater")
mat.pval[k,4]<-randtest$pvalue
}
# Exporting Co-occ matrix
cat("Exporting dataset", "\n",append = F)
cat(".............", "\n",append = F)
cat(".............", "\n",append = F)
cat(".............", "\n",append = F)
hist(as.vector(mat.pval[,2]), xlab="Zscore", main = paste(""))
abline(v=c(2,-2),col = "red")
mat.pval.names<-data.frame(df.obs.c.coef[,3:4],mat.pval,df.obs.c.coef.perm[,5])
mat.pval.names2<-data.frame(mat.pval.names[,1:3],mat.pval.names[,7],mat.pval.names[,4:6])
names(mat.pval.names2)[3]<-"obs.C-score"
names(mat.pval.names2)[4]<-"exp.C-score"
write.table(mat.pval.names2,file=paste(outpath,"\\Cscores01.txt", sep=""),sep="\t",append=F,row.names=F,col.names=T,quote=F)
tab<-mat.pval.names2
v<-c(0)
for (i in 1:nrow(tab)){
if (tab[i,6]<=0.05||tab[i,7]<=0.05){
v<-c(v,i)
}
}
m<-data.frame()
for(j in 1:length(v)){
m<-rbind(m,tab[v[j],])
}
m1<-na.omit(m)
write.table(m1,file=paste(outpath,"\\Sign_Cscores01.txt",sep=""),sep="\t",append=F,row.names=F,col.names=T,quote=F)
write.table(mat.perm, file=paste(outpath,"\\MatrixPermutations01.txt",sep=""),sep="\t",append=F,row.names=F,col.names=T,quote=F)
l<-list(ObsCscoreTot=CscoreTot, SimCscoreTot=SimulatedCscore, PVal.less=pval.less,PVal.greater=pval.greater,Z.score=Zscore)
return(l)
cat("Computations finished!", "\n",append = F)
# END FUNCTION
}
### Calculating C-Score ###
data.in <- comm
nperm <- 10000
outpath <- "C:/Users/soare/OneDrive/Atual/Artigos em andamento/ariidae/MS_Ariid_Cooccurrence/results"
res <- ecospat.Cscore01(comm,nperm,outpath)
### Importing and formatting dataset ###
# This script was retrieved from D'Amen et al. (2017). If you use it, cite:
# D'Amen, Gotelli & Guisan (2017) Disentangling biotic interactions, environmental filters, and dispersal limitation as drivers of species co-occurrence. Ecography, 41 (8): 1233-1244. ##
nperm <- 10000
outpath <- "C:/Users/soare/OneDrive/Atual/Artigos em andamento/ariidae/MS_Ariid_Cooccurrence/results"
coocc.tab.all<-read.table("results/Cscores01.txt",h=T)
obs.r<-data.frame(coocc.tab.all$obs.C.score) # Observed C-scores
pairs<-coocc.tab.all[,1:2] # Names of significant pairs
CooccProb<-read.table("MatrixPermutations01.txt", h=T)  # Null C-scores
CooccProb.pairs<-cbind(pairs,CooccProb) # Attribute names of pairs to Null values
CooccProb.pairs.mean<-apply(CooccProb.pairs[,3:nperm],1,mean) # Calculate mean of null values
CooccProb.pairs.sd<-apply(CooccProb.pairs[,3:nperm],1,sd) # Calculate standard deviation of null values
CooccProb.stat<-data.frame(pairs,CooccProb.pairs.mean,CooccProb.pairs.sd)
### Assign each C-score to 22 evenly spaced bins ###
n.bin<-22
colnames(obs.r)<-"Cscore"
obs.r$bin<- cut(obs.r$Cscore, breaks=seq(0,1,by=1/n.bin),include.lowest=TRUE,labels=1:n.bin)
obs.r<-cbind(obs.r,pairs)
### Calculate how many pairs are in each bin ###
obs.r1<-obs.r[order(obs.r[,2], obs.r[,1]),]
obs.bin.summary<-as.data.frame(table(obs.r1$bin))
obs.bin.meanCS<-aggregate(obs.r1$Cscore, list(obs.r1$bin), mean)
names(obs.bin.summary)<-c("bin","n.pairs")
### Calculate the null expectation of C-scores in each bin ###
matrix.null.bins<-CooccProb
matrix.null.bin.meanCS<-data.frame(seq(1:n.bin))
names(matrix.null.bin.meanCS)<-"Group.1"
for (i in 1:ncol(CooccProb)){
null.bin<-cut(CooccProb[,i], breaks=seq(0,1,by=1/n.bin), include.lowest=TRUE, labels=1:n.bin)
matrix.null.bins[,i]<-null.bin
null.bin1<-cbind(CooccProb[,i],null.bin)
null.bin.meanCS<-aggregate(null.bin1[,1],list(null.bin1[,2]),mean)
matrix.null.bin.meanCS<-merge(matrix.null.bin.meanCS, null.bin.meanCS, by="Group.1", all.x=T)}
nperm<-10000
tab.summary<-data.frame(matrix(data=NA,byrow=T,nrow=n.bin,ncol=nperm)) #table with the number of pairs in each bin for each null community
for (z in 1:nperm){
col.summary<-as.data.frame(table(matrix.null.bins[,z]))
tab.summary[,z]<-col.summary[,2]
colnames(tab.summary)[z]<-z}
matrix.null.bin.meanCS[is.na(matrix.null.bin.meanCS)] <- 0
tab.summary.meanCS<-apply(matrix.null.bin.meanCS[,2:(nperm+1)],1,mean, na.rm=T)
null.meanCS<-cbind(seq(1:n.bin),tab.summary.meanCS)
names(null.meanCS)<-c("bin", "null.meanCS")
### Calculate the mean and 95% confidence interval for each bin ###
myci <- function(t) {
n <- length(t)
se <- sd(t)/sqrt(n)
m <- mean(t)
cv <- qt(0.975,df=n-1)
c(m-cv*se,m+cv*se)
}
mean.pairs.bin<-(apply(tab.summary,1,mean))
CI.pairs.bin<-t(apply(tab.summary,1,myci))
sd.pairs.bin<-apply(tab.summary,1,sd)
stat.pairs.bin<-data.frame(seq(1:n.bin),mean.pairs.bin,CI.pairs.bin)
names(stat.pairs.bin)<-c("bin","MEAN","UP.CI","LOW.CI")
half.bin<-signif(((1/n.bin)/2),2)
bin.mean<-seq(0,1,by=1/n.bin)-half.bin
bin.mean<-bin.mean[2:(n.bin+1)]
# Table with observed number of pairs for each bin #
obs.bin.summary2<-cbind(obs.bin.summary,bin.mean)
# Table with mean and CI null number of pairs for each bin #
stat.pairs.bin2<-cbind(stat.pairs.bin,bin.mean)
### Comparison of observed (black) and null (white) number of pairs in each bin ###
plot(x=stat.pairs.bin2[,5],y=stat.pairs.bin2[,2], xlab="C-score",ylab="Number of pairs")
points(y=obs.bin.summary2[,2],x=obs.bin.summary2[,3], pch=16)
## Selecting the species pairs of the bins which the observed number of significant pairs
# were more than the mean number of significant pairs
tab.finalBayesM<-data.frame(matrix(ncol=ncol(obs.r1),nrow=0))
names(tab.finalBayesM)<-names(obs.r1)
for(j in 1:n.bin){
obs.r2<-obs.r1[obs.r1$bin==j,]
if((obs.bin.summary[j,2]>stat.pairs.bin[j,2])==T){   # if the observed number of species in the bin is higher
# than the mean number of species expected by null communities in the same bin
exp.mean<-as.numeric(null.meanCS[j,2])             # we retain the pairs with a C-score higher than the mean C-score measured from null community in that bin
obs.r3<-obs.r2[obs.r2$Cscore>exp.mean,]
tab.finalBayesM<-rbind(tab.finalBayesM, obs.r3)
}}
### Retain only pairs statistically significant in an individual test ###
BayesM_merge<-merge(tab.finalBayesM,coocc.tab.all,by.y=c("Sp1","Sp2"))
sign.BayesM<-BayesM_merge[which(BayesM_merge$pval_less<0.05|BayesM_merge$pval_greater<0.05),]
write.table(sign.BayesM,"results/Sign.BayesM.txt", sep="\t")
### Importing and formatting dataset ###
# This script was retrieved from D'Amen et al. (2017). If you use it, cite:
# D'Amen, Gotelli & Guisan (2017) Disentangling biotic interactions, environmental filters, and dispersal limitation as drivers of species co-occurrence. Ecography, 41 (8): 1233-1244. ##
nperm <- 10000
outpath <- "C:/Users/soare/OneDrive/Atual/Artigos em andamento/ariidae/MS_Ariid_Cooccurrence/results"
coocc.tab.all<-read.table("results/Cscores01.txt",h=T)
obs.r<-data.frame(coocc.tab.all$obs.C.score) # Observed C-scores
pairs<-coocc.tab.all[,1:2] # Names of significant pairs
CooccProb<-read.table("MatrixPermutations01.txt", h=T)  # Null C-scores
CooccProb<-read.table("results/MatrixPermutations01.txt", h=T)  # Null C-scores
CooccProb.pairs<-cbind(pairs,CooccProb) # Attribute names of pairs to Null values
CooccProb.pairs.mean<-apply(CooccProb.pairs[,3:nperm],1,mean) # Calculate mean of null values
CooccProb.pairs.sd<-apply(CooccProb.pairs[,3:nperm],1,sd) # Calculate standard deviation of null values
CooccProb.stat<-data.frame(pairs,CooccProb.pairs.mean,CooccProb.pairs.sd)
### Assign each C-score to 22 evenly spaced bins ###
n.bin<-22
colnames(obs.r)<-"Cscore"
obs.r$bin<- cut(obs.r$Cscore, breaks=seq(0,1,by=1/n.bin),include.lowest=TRUE,labels=1:n.bin)
obs.r<-cbind(obs.r,pairs)
### Calculate how many pairs are in each bin ###
obs.r1<-obs.r[order(obs.r[,2], obs.r[,1]),]
obs.bin.summary<-as.data.frame(table(obs.r1$bin))
obs.bin.meanCS<-aggregate(obs.r1$Cscore, list(obs.r1$bin), mean)
names(obs.bin.summary)<-c("bin","n.pairs")
### Calculate the null expectation of C-scores in each bin ###
matrix.null.bins<-CooccProb
matrix.null.bin.meanCS<-data.frame(seq(1:n.bin))
names(matrix.null.bin.meanCS)<-"Group.1"
for (i in 1:ncol(CooccProb)){
null.bin<-cut(CooccProb[,i], breaks=seq(0,1,by=1/n.bin), include.lowest=TRUE, labels=1:n.bin)
matrix.null.bins[,i]<-null.bin
null.bin1<-cbind(CooccProb[,i],null.bin)
null.bin.meanCS<-aggregate(null.bin1[,1],list(null.bin1[,2]),mean)
matrix.null.bin.meanCS<-merge(matrix.null.bin.meanCS, null.bin.meanCS, by="Group.1", all.x=T)}
nperm<-10000
tab.summary<-data.frame(matrix(data=NA,byrow=T,nrow=n.bin,ncol=nperm)) #table with the number of pairs in each bin for each null community
for (z in 1:nperm){
col.summary<-as.data.frame(table(matrix.null.bins[,z]))
tab.summary[,z]<-col.summary[,2]
colnames(tab.summary)[z]<-z}
matrix.null.bin.meanCS[is.na(matrix.null.bin.meanCS)] <- 0
tab.summary.meanCS<-apply(matrix.null.bin.meanCS[,2:(nperm+1)],1,mean, na.rm=T)
null.meanCS<-cbind(seq(1:n.bin),tab.summary.meanCS)
names(null.meanCS)<-c("bin", "null.meanCS")
### Calculate the mean and 95% confidence interval for each bin ###
myci <- function(t) {
n <- length(t)
se <- sd(t)/sqrt(n)
m <- mean(t)
cv <- qt(0.975,df=n-1)
c(m-cv*se,m+cv*se)
}
mean.pairs.bin<-(apply(tab.summary,1,mean))
CI.pairs.bin<-t(apply(tab.summary,1,myci))
sd.pairs.bin<-apply(tab.summary,1,sd)
stat.pairs.bin<-data.frame(seq(1:n.bin),mean.pairs.bin,CI.pairs.bin)
names(stat.pairs.bin)<-c("bin","MEAN","UP.CI","LOW.CI")
half.bin<-signif(((1/n.bin)/2),2)
bin.mean<-seq(0,1,by=1/n.bin)-half.bin
bin.mean<-bin.mean[2:(n.bin+1)]
# Table with observed number of pairs for each bin #
obs.bin.summary2<-cbind(obs.bin.summary,bin.mean)
# Table with mean and CI null number of pairs for each bin #
stat.pairs.bin2<-cbind(stat.pairs.bin,bin.mean)
### Comparison of observed (black) and null (white) number of pairs in each bin ###
plot(x=stat.pairs.bin2[,5],y=stat.pairs.bin2[,2], xlab="C-score",ylab="Number of pairs")
points(y=obs.bin.summary2[,2],x=obs.bin.summary2[,3], pch=16)
## Selecting the species pairs of the bins which the observed number of significant pairs
# were more than the mean number of significant pairs
tab.finalBayesM<-data.frame(matrix(ncol=ncol(obs.r1),nrow=0))
names(tab.finalBayesM)<-names(obs.r1)
for(j in 1:n.bin){
obs.r2<-obs.r1[obs.r1$bin==j,]
if((obs.bin.summary[j,2]>stat.pairs.bin[j,2])==T){   # if the observed number of species in the bin is higher
# than the mean number of species expected by null communities in the same bin
exp.mean<-as.numeric(null.meanCS[j,2])             # we retain the pairs with a C-score higher than the mean C-score measured from null community in that bin
obs.r3<-obs.r2[obs.r2$Cscore>exp.mean,]
tab.finalBayesM<-rbind(tab.finalBayesM, obs.r3)
}}
### Retain only pairs statistically significant in an individual test ###
BayesM_merge<-merge(tab.finalBayesM,coocc.tab.all,by.y=c("Sp1","Sp2"))
sign.BayesM<-BayesM_merge[which(BayesM_merge$pval_less<0.05|BayesM_merge$pval_greater<0.05),]
write.table(sign.BayesM,"results/Sign.BayesM.txt", sep="\t")
# This script was adapted from D'Amen et al. (2017). If you use it, cite:
# D'Amen, Gotelli & Guisan (2017) Disentangling biotic interactions, environmental filters, and dispersal limitation as drivers of species co-occurrence. Ecography, 41 (8): 1233-1244. ##
### Loading packages ###
library(reshape)
library(ggplot2)
library(gridExtra)
#### Loading and formatting dataset ###
data<-read.table("data/trawling data.txt",header=T)
presabs<-cast(data[,c(1:3)],trawl~species,value='pres',fun.aggregate=mean)
presabs[is.na(presabs)]<-0
colnames(presabs)[1]<-"plot"
sign.BayesM<-read.table("results/sign.BayesM.txt",header=T)
pairs<-sign.BayesM[,c(1:2)]
pairs<-cbind(pairs,ifelse((sign.BayesM$obs.C.score-sign.BayesM$exp.C.score)>0,"SEGR","AGGR"))
colnames(pairs)[3]<-"NullModel"
coor<-aggregate(data[,5:6],list(data$trawl),mean)
row.names(coor)<-coor$Group.1
colnames(coor)[1]<-"plot"
Dist<-read.table("results/avDist.txt",header=T,row.names=1)
Dist<-cbind(Dist,coor$plot)
colnames(Dist)[2]<-"plot"
env<-read.table("results/env_pcs.txt",header=T)
env<-cbind(env,coor$plot)
colnames(env)[4]<-"plot"
calculate_mode <- function(x) { #function to return the season of each trawl
uniqx <- unique(na.omit(x))
uniqx[which.max(tabulate(match(x, uniqx)))]
}
season<-aggregate(data[,10],list(data$trawl),calculate_mode)
row.names(season)<-season$Group.1
colnames(season)[1]<-"plot"
### Preparing preparation of the columns for store the results from the tests  ###
pairs$coor.test<-NA
pairs$pillai.coor.test<-NA
pairs$env.test<-NA
pairs$r.env.test<-NA
pairs$Dist.test<-NA
pairs$r.Dist.test<-NA
pairs$season.test<-NA
pairs$dry.season.test<-NA
pairs$wet.season.test<-NA
pairs
### Identify the four co-occurrence classes for each pair of species in each site:
# ("co00"= both absent, "co11"=both present, "co01" and "co10"= checkerboard distributions)
# and analyze the importance of spatial configuration, environment, functional distinctiveness and seasonality
for (i in 1:nrow(pairs)) {
sp1<-as.character(pairs[i,1])
sp2<-as.character(pairs[i,2])
tab<-presabs[,c(sp1,sp2)]
x<-pairs[pairs$Sp1==sp1&pairs$Sp2==sp2,]
tab$id<-apply(tab,1,sum)     # identification of the four classes
tab$id[tab$id == 2] <- "co11"
tab$id[tab$id == 0] <- "co00"
tab$id[tab[[1]]==1&tab[[2]]==0] <- "co10"
tab$id[tab[[1]]==0&tab[[2]]==1] <- "co01"
tab<-cbind(presabs[1],tab)  # association of the site id to the smaller table
if (x$NullModel=="SEGR") {                             # identification of the pattern of segregation or
tab1<-tab[tab[[4]]=="co10"|tab[[4]]=="co01",]          # aggregation for the considered species pairs
}else if (x$NullModel=="AGGR") {                       # to select the sites to test in the following lines
tab1<-tab[tab[[4]]=="co11"|tab[[4]]=="co00",]
}
#### Test of spatial arrangement: MANOVA on the coordinates
coor.tab1<-merge(coor, tab1, by.y="plot",all = FALSE)
fac1=factor(tab1$id)
xx=as.matrix(coor.tab1[,2:3])
m.coor=manova(xx~fac1)
sum.coor=summary(m.coor)
pairs$coor.test[i]<-sum.coor$stats[1,6]
pairs$pillai.coor.test[i]<-sum.coor$stats[1,2]
#### Test of functional arrangement: ANOVA on the distinctiveness
Dist.tab1<-merge(Dist, tab1, by.y="plot",all = FALSE)
fac1=factor(Dist.tab1$id)
xx=as.matrix(Dist.tab1[,2])
anova.Dist<-aov(xx~fac1)
sum.Dist<-summary(anova.Dist)
boxplot(xx~fac1)
pairs$Dist.test[i]<-sum.Dist[[1]][[1,"Pr(>F)"]]
pairs$r.Dist.test[i]<-summary(lm(xx~fac1))$r.squared
#### Test of environmental filter: ANOVA on the PCA axes
env.tab1<-merge(env,tab1, by.y="plot",all = FALSE)
fac1=factor(env.tab1$id)
yy<-as.matrix(env.tab1[,2])
m.env<-aov(yy~fac1)
sum.env=summary(m.env)
boxplot(yy~fac1)
pairs$env.test[i]<-sum.env[[1]][[1,"Pr(>F)"]]
pairs$r.env.test[i]<-summary(lm(yy~fac1))$r.squared
#### Test of seasonality: chi-square tests
season.tab1<-merge(season,tab,by.y="plot",all = FALSE)
season.tab1$id<-as.factor(season.tab1$id)
levels(season.tab1$id)[levels(season.tab1$id)=="co10"] <- "SEGR"
levels(season.tab1$id)[levels(season.tab1$id)=="co01"] <- "SEGR"
levels(season.tab1$id)[levels(season.tab1$id)=="co11"] <- "AGGR"
levels(season.tab1$id)[levels(season.tab1$id)=="co00"] <- "AGGR"
fac1=season.tab1$id
yy<-season.tab1$x
m.season<-chisq.test(table(fac1,yy))
pairs$season.test[i]<-m.season$p.value
pairs$dry.season.test[i]<-m.season$observed[1,1]/m.season$observed[2,1]
pairs$wet.season.test[i]<-m.season$observed[1,2]/m.season$observed[2,2]
}
pairs
write.table(pairs,"results/ResultBlois.txt", sep = "\t")
### Plotting Figure 4 ###
tab0<-presabs[,c("Aquadriscutis","Sparkeri")]
x<-pairs[pairs$Sp1=="Aquadriscutis"&pairs$Sp2=="Sparkeri",]
tab0$id<-apply(tab0,1,sum)     # identification of the four classes
tab0$id[tab0$id == 2] <- "Double presence"
tab0$id[tab0$id == 0] <- "Double absence"
tab0$id[tab0[[1]]==1&tab0[[2]]==0] <- "co10"
tab0$id[tab0[[1]]==0&tab0[[2]]==1] <- "co01"
tab0<-cbind(presabs[1],tab0)  # association of the site id to the smaller table
Dist.tab0<-merge(Dist,tab0, by.y="plot",all = FALSE)
Dist.tab0<-droplevels(Dist.tab0[!Dist.tab0$id=='co01',])
Dist.tab0<-droplevels(Dist.tab0[!Dist.tab0$id=='co10',])
AquSpa<-ggplot()+
geom_boxplot(aes(x=Dist.tab0$id,y=Dist.tab0$AvDist),fill="grey")+
ylab("FDis")+
xlab("")+
theme(panel.background = element_rect(fill = "white", colour = "black", size = 0.5), # opcoes graficas
panel.grid.major = element_line(colour = NA),
panel.grid.minor = element_line(colour = NA),
axis.text = element_text(colour = "black", size = 10),
axis.text.x = element_blank(),
axis.title.x=element_blank(),
axis.title = element_text(colour = "black", size = 12, face = "bold"),
legend.title = element_blank(),
legend.background = element_rect(fill = "white"),
legend.text = element_text(face = "bold", colour = "black", size = 16))
tab1<-presabs[,c("Arugispinis","Cspixii")]
x<-pairs[pairs$Sp1=="Arugispinis"&pairs$Sp2=="Cspixii",]
tab1$id<-apply(tab1,1,sum)     # identification of the four classes
tab1$id[tab1$id == 2] <- "Double presence"
tab1$id[tab1$id == 0] <- "Double absence"
tab1$id[tab1[[1]]==1&tab1[[2]]==0] <- "co10"
tab1$id[tab1[[1]]==0&tab1[[2]]==1] <- "co01"
tab1<-cbind(presabs[1],tab1)  # association of the site id to the smaller table
Dist.tab1<-merge(Dist,tab1, by.y="plot",all = FALSE)
Dist.tab1<-droplevels(Dist.tab1[!Dist.tab1$id=='co01',])
Dist.tab1<-droplevels(Dist.tab1[!Dist.tab1$id=='co10',])
AruCar<-ggplot()+
geom_boxplot(aes(x=Dist.tab1$id,y=Dist.tab1$AvDist),fill="grey")+
ylab("")+
xlab("Co-occurrence patterns")+
theme(panel.background = element_rect(fill = "white", colour = "black", size = 0.5), # opcoes graficas
panel.grid.major = element_line(colour = NA),
panel.grid.minor = element_line(colour = NA),
axis.text = element_text(colour = "black", size = 10),
axis.title = element_text(colour = "black", size = 12, face = "bold"),
legend.title = element_blank(),
legend.background = element_rect(fill = "white"),
legend.text = element_text(face = "bold", colour = "black", size = 16))
figure4<-grid.arrange(AquSpa,AruCar,nrow=2)
ggsave("Figures/Figure 4.png",figure4,dpi=600,height=9,width=8,units=c("cm"))
